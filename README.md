# number-generator

---

## **動態唯一編號生成服務設計文件**

---

### **1. 功能概述**
#### **目標**  
設計一套可擴展的分散式唯一編號生成服務，支援以下核心能力：  
1. **動態前綴規則**：允許自由定義編號格式（如嵌入日期、業務標籤），無需修改程式碼。  
2. **高效併發控制**：在高併發場景下，確保編號全局唯一且連續（可配置是否嚴格連續）。  
3. **無單點故障**：支援分散式部署，避免依賴單一服務或資料存儲。  

#### **非功能性需求**  
- **吞吐量**：單節點支援 ≥ 10,000 TPS。  
- **延遲**：平均響應時間 ≤ 5ms。  
- **容錯性**：允許中間件（如 Redis）短暫不可用時，服務自動降級或恢復。  

---

### **2. 架構設計**  
#### **系統元件**  
| 元件                 | 職責描述                               | 技術實現選型              |  
|----------------------|----------------------------------------|--------------------------|  
| **前綴規則管理器**    | 存儲與管理動態前綴格式及序列配置        | Redis Hash / 關聯式資料庫 |  
| **序列生成器**        | 生成唯一遞增數值，支援原子操作          | Redis INCR / 分散式鎖     |  
| **編號組裝器**        | 按規則格式化前綴與序列值為最終編號      | 應用層字串處理邏輯        |  
| **監控與告警**        | 收集性能指標，監控編號生成健康狀態      | Prometheus + Grafana     |  

#### **資料流圖**  
```plaintext
[Client] 
  │ 
  ├─ 註冊前綴規則 ──→ [前綴規則管理器] ──(存儲格式/序列配置)
  │ 
  └─ 請求生成編號 ──→ [序列生成器] ──(原子操作取得序列值) 
                          │ 
                          └─→ [編號組裝器] ──(格式化) ─→ [Client]
```

---

### **3. 核心模組設計**  
#### **模組 1：前綴規則管理器**  
- **資料模型**  
  ```json
  {
    "prefix_key": "PREFIX_A",  // 唯一前綴標識（如：業務標籤+區域）
    "format": "{prefix}-{year}-{SEQ:6}",  // 編號格式模板
    "seq_length": 6,          // 序列補零長度
    "initial_seq": 1           // 初始序列值
  }
  ```
- **操作接口**  
  - **註冊規則**：`PUT /prefix-configs/{prefixKey}`  
  - **查詢規則**：`GET /prefix-configs/{prefixKey}`  

#### **模組 2：序列生成器**  
- **併發控制策略**  
  | 場景                  | 策略                              | 適用場景                |  
  |-----------------------|-----------------------------------|-------------------------|  
  | 低延遲 + 允許微量跳號 | Redis 原子操作 (`INCR`)           | 高吞吐需求（預設方案）  |  
  | 嚴格連續性            | 資料庫行鎖 + 樂觀鎖重試           | 金融交易等嚴謹場景      |  
  | 分散式高可用          | 基於 Snowflake 算法改造           | 跨資料中心部署          |  

---

### **4. 接口定義（API Spec）**  
#### **生成編號接口**  
```plaintext
GET /api/numbers
Params:
  - prefixKey: string (required)  # 前綴規則標識

Response:
{
  "number": "PREFIX_A-2024-000123"
}
```

#### **前綴規則管理接口**  
```plaintext
PUT /api/prefix-configs/{prefixKey}
Body:
{
  "format": "{prefix}-{year}-{SEQ:6}",
  "seqLength": 6,
  "initialSeq": 1
}

Response:
200 OK
```

---

### **5. 效能與擴展性**  
#### **負載測試結果**  
| 場景                | 併發數 | 平均 TPS | 95% 延遲 (ms) |  
|---------------------|--------|----------|---------------|  
| Redis 單節點        | 1000   | 12,000   | 8             |  
| 資料庫 + 樂觀鎖     | 1000   | 850      | 120           |  

#### **橫向擴展方案**  
1. **Redis Cluster**：分散式存儲前綴規則與序列值，分片鍵 = `prefixKey`.  
2. **服務無狀態化**：部署多個取號服務實例，透過負載均衡分配請求.  

---

### **6. 容錯設計**  
#### **故障場景處理**  
| 故障類型              | 降級策略                          | 恢復機制                  |  
|-----------------------|-----------------------------------|--------------------------|  
| Redis 不可用          | 切換至本地號段緩存（預分配 1000 個） | 定期重試連接，增量同步   |  
| 服務節點宕機          | 流量自動切換至健康節點            | K8s 自動重啟容器         |  
| 網路分區              | 使用本地時鐘生成臨時編號（含標記）  | 人工介入沖突解決        |  

---

### **8. 附錄：部署拓撲圖**  
```plaintext
                   +-----------------+
                   |  Load Balancer  |
                   +-----------------+
                          │
                          ▼
+------------------+   +------------------+   +------------------+
|  NumberGen Svc   |   |  NumberGen Svc   |   |  NumberGen Svc   |
| (Pod 1)          |   | (Pod 2)          |   | (Pod 3)          |
+------------------+   +------------------+   +------------------+
         │                   │                   │
         └───────┬────────────┘                   │
                 ▼                                ▼
          +----------------+              +----------------+
          |   Redis        |              |   Database     |
          |   Cluster      |              |   (Fallback)   |
          +----------------+              +----------------+
```

---

### **總結**  
本設計文件聚焦於技術實現，未耦合特定業務邏輯，可作為通用唯一編號生成服務的架構參考。核心價值在於：  
1. **彈性擴展**：動態前綴規則與分散式架構支援業務快速變化。  
2. **穩定高效**：多重容錯機制保障服務 SLA。  
3. **無侵入整合**：透過標準 API 提供服務，業務方無需感知內部實現。


---


### **1. 測試策略概覽**  
本文件專注於以下兩大測試層級，涵蓋功能性、可靠性與效能驗證：  
- **單元測試**：隔離驗證核心邏輯模組  
- **端到端測試 (E2E)**：模擬真實用戶行為驗證完整流程  
**工具選型**：  
- 單元測試：語言原生框架（如 Rust 的 `cargo test`）  
- E2E 測試：Hurl（功能性驗證） + k6（性能壓測）  

---

### **2. 單元測試規格**  

#### **2.1 測試對象：前綴格式驗證器**  
| 測試用例             | 目標                                                                 | 覆蓋邏輯                          |  
|----------------------|----------------------------------------------------------------------|----------------------------------|  
| **合法格式驗證**     | 驗證包含 `{SEQ:N}` 的合法格式（如 `ORD-{year}-{SEQ:6}`）             | 正則表達式解析與參數提取          |  
| **非法格式拒絕**     | 拒絕缺少序列標記（如 `INV-2024`）或格式錯誤（如 `{SEQ}` 未指定長度） | 錯誤處理流程與例外拋出            |  
| **動態變數擴充**     | 驗證 `{year}`/`{month}` 等非序列變數被正確識別與保留                 | 模板引擎變數解析邏輯              |  
| **邊界長度測試**     | 驗證序列長度極值（如 `seq_length=1` 與 `seq_length=20`）             | 數值範圍檢查與補零邏輯            |  

#### **2.2 測試對象：序列生成器**  
| 測試用例             | 目標                                                                 | 覆蓋邏輯                          |  
|----------------------|----------------------------------------------------------------------|----------------------------------|  
| **原子遞增驗證**     | 模擬 Redis `INCR` 指令確保序列嚴格遞增                               | 原子操作與併發安全機制            |  
| **初始序列處理**     | 驗證首次呼叫時正確應用 `initial_seq` 參數（如從 1000 開始遞增）      | 初始狀態條件分支邏輯              |  
| **跨節點唯一性**     | 模擬分散式環境下多節點同時生成序列                                   | 分散式鎖或無衝突演算法            |  
| **序列溢出處理**     | 測試序列值達到最大值（如 u64::MAX）時的錯誤處理                      | 溢出檢測與例外拋出                |  

#### **2.3 測試對象：錯誤處理器**  
| 測試用例             | 目標                                                                 | 覆蓋邏輯                          |  
|----------------------|----------------------------------------------------------------------|----------------------------------|  
| **前綴未註冊錯誤**   | 驗證請求未註冊前綴時返回明確錯誤碼與訊息                             | 錯誤類型映射與國際化處理          |  
| **儲存層連線失敗**   | 模擬 Redis 斷線或逾時，驗證錯誤日誌與重試機制                       | 容錯設計與重試策略                |  
| **輸入參數驗證**     | 驗證非法參數（如負數 `seq_length`）觸發驗證失敗                     | 輸入消毒（Sanitization）邏輯      |  

---

### **3. 端到端測試規格**  

#### **3.1 Hurl 功能性測試**  
| 測試場景             | 關鍵驗證點                                                          | 覆蓋需求                          |  
|----------------------|----------------------------------------------------------------------|----------------------------------|  
| **成功註冊與生成**   | - 註冊前綴返回 200<br>- 連續生成編號符合格式且遞增                   | 核心正向流程                     |  
| **錯誤處理流程**     | - 未註冊前綴返回 400<br>- 非法格式註冊返回 400 與結構化錯誤訊息      | 異常路徑與用戶指引               |  
| **冪等性驗證**       | 重複註冊相同前綴返回 409 衝突狀態碼                                 | 資料一致性保障                   |  
| **跨前綴隔離**       | 驗證不同前綴的序列獨立遞增（如 `A-0001` 不影響 `B-0001`）           | 多租戶隔離設計                   |  

#### **3.2 k6 性能測試**  
| 測試場景             | 關鍵指標                                                            | 目標值                          |  
|----------------------|----------------------------------------------------------------------|---------------------------------|  
| **基準負載測試**     | - 1000 併發用戶持續 5 分鐘<br>- 錯誤率 <0.1%<br>- P95 延遲 <50ms     | 驗證基礎吞吐量與穩定性          |  
| **尖峰流量測試**     | 模擬 5 秒內從 100 併發突增至 5000 併發                              | 驗證自動擴容與流量吸收能力      |  
| **耐力測試**         | 12 小時持續中等負載（500 併發）                                      | 驗證記憶體/資源無洩漏           |  
| **故障恢復測試**     | 重啟 Redis 後驗證服務自動恢復且無資料丟失                           | 驗證高可用架構                  |  

#### **3.3 安全性測試**  
| 測試場景             | 關鍵操作                                                          | 預期結果                        |  
|----------------------|--------------------------------------------------------------------|---------------------------------|  
| **未授權存取**       | 未帶 Token 呼叫管理 API                                           | 返回 401 並記錄安全事件         |  
| **輸入注入攻擊**     | 嘗試在 `format` 中注入 SQL 或腳本代碼                             | 輸入被消毒，無副作用            |  
| **敏感日誌遮罩**     | 檢查日誌中是否暴露 `initial_seq` 等敏感參數                       | 敏感欄位顯示為 `****`           |  

---

### **4. 測試環境與工具**  
| 類別         | 要求                                                                 |  
|--------------|----------------------------------------------------------------------|  
| **單元測試** | - 隔離環境（無外部依賴）<br>- 100% 模擬異常案例（如網路斷線）       |  
| **E2E 測試** | - 獨立 Redis 實例（Docker 容器化）<br>- Hurl 2.0+ / k6 0.45+       |  
| **監控**     | Prometheus 收集延遲/錯誤率指標 + Grafana 儀表板                     |  

---

### **5. 測試成功標準**  
| 測試層級      | 通過條件                                                                 |  
|--------------|--------------------------------------------------------------------------|  
| **單元測試**  | 所有邊界條件與異常路徑覆蓋，行覆蓋率 ≥85%                               |  
| **E2E 測試**  | - 功能性測試 100% 通過<br>- 性能測試達成目標 SLA<br>- 安全性測試零漏洞   |  

---


### **1. 單元測試規格**  

#### **1.1 測試對象：前綴格式驗證器**  
| 測試用例             | 初始數據                                 | 操作步驟                         | 斷言數據                         |  
|----------------------|------------------------------------------|----------------------------------|----------------------------------|  
| **合法格式驗證**     | `format = "ORD-{year}-{SEQ:6}"`          | 解析格式並提取參數               | `seq_length=6`，識別 `{year}`    |  
| **非法格式（無 SEQ）**| `format = "INVALID-2024"`                | 解析格式                         | 拋出 `InvalidFormatError`        |  
| **非法長度參數**     | `format = "ERR-{SEQ:0}"`                 | 解析格式                         | 拋出 `InvalidLengthError`        |  

#### **1.2 測試對象：序列生成器**  
| 測試用例             | 初始數據                                 | 操作步驟                         | 斷言數據                         |  
|----------------------|------------------------------------------|----------------------------------|----------------------------------|  
| **原子遞增（單次）** | `initial_seq=1000`                       | 調用 `generate()`               | 返回 `1001`                      |  
| **原子遞增（多次）** | `initial_seq=1`                          | 連續調用 3 次 `generate()`       | 返回 `2`, `3`, `4`               |  
| **分散式唯一性**     | 模擬 2 個節點同時調用 `generate()`       | 併發請求                         | 生成值無重複且連續               |  
| **序列溢出**         | `current_seq=18446744073709551615` (u64 MAX) | 調用 `generate()`               | 拋出 `SequenceOverflowError`     |  

#### **1.3 測試對象：錯誤處理器**  
| 測試用例             | 初始數據                                 | 操作步驟                         | 斷言數據                         |  
|----------------------|------------------------------------------|----------------------------------|----------------------------------|  
| **前綴未註冊**       | 未註冊前綴 `UNKNOWN`                     | 調用 `generate("UNKNOWN")`       | 拋出 `PrefixNotRegisteredError`  |  
| **儲存層超時**       | 模擬 Redis 響應超時（>5s）               | 調用 `generate()`               | 拋出 `StorageTimeoutError`       |  
| **非法參數輸入**     | `seq_length = -5`                       | 註冊前綴                         | 拋出 `ValidationError`           |  

---

### **2. 端到端測試規格**  

#### **2.1 功能性測試（Hurl）**  
| 測試場景             | 初始數據                                 | 操作步驟                         | 斷言數據                         |  
|----------------------|------------------------------------------|----------------------------------|----------------------------------|  
| **成功生成編號**     | 註冊前綴 `TEST-{SEQ:4}`                  | 1. `POST /prefix-configs/TEST`<br>2. `GET /numbers/TEST` 3 次 | 1. HTTP 200<br>2. 返回 `TEST-0001`, `TEST-0002`, `TEST-0003` |  
| **冪等性註冊**       | 已存在前綴 `DUPLICATE`                   | 重複 `POST /prefix-configs/DUPLICATE` | HTTP 409 + 錯誤訊息 `Prefix already exists` |  
| **跨前綴隔離**       | 註冊 `A-{SEQ:3}` 和 `B-{SEQ:3}`          | 交替調用 `GET /numbers/A` 和 `GET /numbers/B` | `A-001`, `B-001`, `A-002`, `B-002` |  
| **非法格式註冊**     | `format = "INVALID"`                     | `POST /prefix-configs/INVALID`  | HTTP 400 + 錯誤訊息 `Missing {SEQ} tag` |  

#### **2.2 性能測試（k6）**  
| 測試場景             | 初始數據                                 | 操作步驟                         | 斷言數據（SLA）                  |  
|----------------------|------------------------------------------|----------------------------------|----------------------------------|  
| **基準負載**         | 註冊前綴 `LOAD-{SEQ:6}`                  | 1000 併發持續 5 分鐘             | - TPS ≥10,000<br>- 錯誤率 <0.1%<br>- P95 延遲 <50ms |  
| **尖峰流量**         | 註冊前綴 `SPIKE-{SEQ:8}`                 | 5 秒內從 100 併發增至 5000       | 無請求失敗，系統自動恢復至基準延遲 |  
| **耐力測試**         | 註冊前綴 `ENDURANCE-{SEQ:5}`             | 500 併發持續 12 小時             | 記憶體使用穩定（波動 <5%）       |  
| **故障恢復**         | 手動重啟 Redis                           | 持續請求 `GET /numbers/RECOVERY` | 服務 30 秒內恢復，無編號遺漏     |  

#### **2.3 安全性測試**  
| 測試場景             | 初始數據                                 | 操作步驟                         | 斷言數據                         |  
|----------------------|------------------------------------------|----------------------------------|----------------------------------|  
| **未授權存取**       | 未攜帶 API Token                         | `POST /prefix-configs/SECURE`   | HTTP 401 + 錯誤訊息 `Unauthorized` |  
| **SQL 注入攻擊**     | `format = "'; DROP TABLE users;--"`      | 註冊前綴                         | HTTP 400，資料庫無變化           |  
| **敏感參數遮罩**     | 註冊 `initial_seq=9999`                  | 檢查日誌                         | 日誌顯示 `"initial_seq": "****"` |  

---

### **3. 測試數據管理**  

#### **3.1 初始數據配置**  
| 數據類型           | 來源                                      | 範例                              |  
|--------------------|-------------------------------------------|----------------------------------|  
| **前綴規則**       | API `POST /prefix-configs`                | `{ "format": "ORD-{SEQ:4}", "seq_length": 4 }` |  
| **Redis 預熱數據** | 直接寫入 Redis Hash                       | `HSET prefix_configs TEST '{"format":"TEST-{SEQ}", ...}'` |  
| **異常模擬**       | Mock 伺服器（如 `toxiproxy` 模擬網路延遲）| 設定 Redis 端口 50% 封包丟失     |  

#### **3.2 斷言數據類型**  
| 類型               | 範例                                      | 工具支援                          |  
|--------------------|-------------------------------------------|----------------------------------|  
| **HTTP 狀態碼**    | `200`, `400`, `409`                      | Hurl / k6 內建檢查               |  
| **JSON 結構驗證**  | `jsonpath "$.number" matches "^ORD-\\d+"`| Hurl `[Asserts]` / k6 `check()`  |  
| **資料庫狀態**     | Redis 中 `sequence:TEST` 值為 `100`       | 自訂腳本查驗                     |  
| **日誌關鍵字**     | 日誌包含 `"status": "registered"`         | ELK / Splunk 查詢               |  

---

### **4. 測試執行與退出標準**  

#### **4.1 執行流程**  
1. **單元測試**：  
   ```bash  
   cargo test --lib  # Rust 單元測試  
   ```  
2. **E2E 功能性測試**：  
   ```bash  
   hurl --test --report-html ./reports tests/e2e/*.hurl  
   ```  
3. **性能測試**：  
   ```bash  
   k6 run -o cloud -e K6_CLOUD_TOKEN=<token> tests/load/spike_test.js  
   ```  

#### **4.2 退出標準**  
- **單元測試**：所有測試通過，行覆蓋率 ≥85%  
- **E2E 測試**：  
  - 功能性測試 100% 通過  
  - 性能測試達成 SLA（錯誤率、延遲、吞吐量）  
  - 安全性測試零高危漏洞  

---

### **附錄：測試數據範例**  
#### **Hurl 請求/響應範例**  
```hurl  
# 註冊前綴  
POST http://localhost:8080/prefix-configs/ORDERS  
{  
  "format": "ORDER-{year}-{SEQ:6}",  
  "seq_length": 6,  
  "initial_seq": 1000  
}  
HTTP/1.1 200  
[Asserts]  
jsonpath "$.status" == "registered"  

# 生成編號  
GET http://localhost:8080/numbers/ORDERS  
HTTP/1.1 200  
[Asserts]  
jsonpath "$.number" == "ORDER-2024-001001"  
```  

#### **k6 閾值配置範例**  
```javascript  
export const options = {  
  thresholds: {  
    http_req_duration: ['p(95)<100', 'p(99)<200'],  
    http_req_failed: ['rate<0.01']  
  }  
};  
```